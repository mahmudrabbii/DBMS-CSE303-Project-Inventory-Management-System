console.log(typeof jQuery);
console.log("are u sure");


var labels=null;


$(window).on("load", async function () {   //  final working
    
        // Output should be "function"



    
let  strarr = await fetchData('fetch_monthly_total_cost_order_product_w.php');


    console.log("Updated seriesData str2:", strarr);
    var num=  toNum(strarr);

    console.log("Updated seriesData int :", num);

    
    initializeChart(strarr);
    
    
});




async function fetchData(path){

    const  seriesData = new Array(12).fill(0); // Initialize all months with 0

    await fetch(path) // Adjust the path as needed
    .then( async response => await response.json())
    .then(data => {
        // Define the labels for the chart (months from January to December)
            labels = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        
    
        // Populate the seriesData array based on the fetched data
        data.forEach(item => {
            // Convert month name to a short format (e.g., "January" -> "Jan")
            var monthIndex = labels.indexOf(item.month.substring(0, 3)); // Get the short version of the month
            if (monthIndex !== -1) {
                seriesData[monthIndex] = item.totalCost; // Set the totalCost at the correct index
            
            }
        });
    
        // Log the entire seriesData array for debugging
    
    })
    .catch(error => console.error('Error fetching data:', error));

    return seriesData;
}

function toNum(stringArray){

    const numberArray = stringArray.map(Number);
    return numberArray;
}
//
function initializeChart(data) {

    console.log("hey there 2");
    const chart = new Chartist.Line(
        "#project-stats",
        {    
            labels: ["Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug","sep"],
            series: [
                data,
            ],
        },
        {
            lineSmooth: Chartist.Interpolation.simple({ divisor: 2 }),
            fullWidth: true,
            showArea: true,
            chartPadding: { right: 20 },
            axisX: { showGrid: false },
            axisY: {
                labelInterpolationFnc: function (value) {
                    return value + "k";
                },
                scaleMinSpace: 40,
                showGrid: false,
            },
            plugins: [
                Chartist.plugins.tooltip({
                    appendToBody: true,
                    pointClass: "ct-point",
                }),
            ],
            low: 0,
            onlyInteger: true,
        }
    );

    chart
        .on("created", function (data) {
            const defs = data.svg.querySelector("defs") || data.svg.elem("defs");
            defs
                .elem("linearGradient", {
                    id: "area-gradient",
                    x1: 1,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                })
                .elem("stop", { offset: 0, "stop-color": "rgba(248,161,236, 1)" })
                .parent()
                .elem("stop", { offset: 1, "stop-color": "rgba(115,150,255, 1)" });

            // Attach hover event listeners to points dynamically
            const points = document.querySelectorAll("circle.ct-point-circle");
            points.forEach((point) => {
                point.addEventListener("mouseover", function (event) {
                    const value = point.getAttribute("ct:value");
                    const rect = point.getBoundingClientRect();
                    const chartRect = document
                        .querySelector("#project-stats")
                        .getBoundingClientRect();

                    showTooltip(value, rect, chartRect);
                });
                point.addEventListener("mouseout", hideTooltip);
            });
        })
        .on("draw", function (data) {
            if (data.type === "point") {
                const circle = new Chartist.Svg("circle", {
                    cx: data.x,
                    cy: data.y,
                    "ct:value": data.value.y,
                    r: 9, // Generic radius for all points
                    class: "ct-point-circle",
                });

                data.element.replace(circle);
            }

            if (data.type === "line" || data.type === "area") {
                data.element.animate({
                    d: {
                        begin: 1000,
                        dur: 1000,
                        from: data.path
                            .clone()
                            .scale(1, 0)
                            .translate(0, data.chartRect.height())
                            .stringify(),
                        to: data.path.clone().stringify(),
                        easing: Chartist.Svg.Easing.easeOutQuint,
                    },
                });
            }
        });

    // Tooltip display function
    function showTooltip(value, rect, chartRect) {
        const tooltip = document.querySelector("#hover-tooltip");
        tooltip.textContent = `Value: ${value}k`;
        tooltip.style.display = "block";

        // Position the tooltip closer to the point and slightly left
        const offsetX = -35; // Move slightly left
        const offsetY = 90; // Move closer to the point

        tooltip.style.left = `${rect.left - chartRect.left + rect.width / 2 + offsetX}px`;
        tooltip.style.top = `${rect.top - chartRect.top + offsetY}px`;
    }

    // Tooltip hide function
    function hideTooltip() {
        const tooltip = document.querySelector("#hover-tooltip");
        tooltip.style.display = "none";
    }

}
